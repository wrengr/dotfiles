# N.B., the [user] values are overridden by the GIT_*_{NAME,EMAIL}
# variables. Thus, even though we set them here, we can still change
# them on each individual machine in our ~/.bash_profile.
[user]
    name = wren romano
    email = wren@community.haskell.org
    # Instruct Git to not try guessing name and email, but yource
    # you to specify them when you set up a new repo:
    #useConfigOnly = true
    # TODO: set up GPG stuff. Not that any project I work on uses
    # it... Once this is enabled here, always pass -S or -s to
    # commit and -s to tag.
    # Cf., <https://mikegerwitz.com/papers/git-horror-story>
    #signingkey = 00000000
[github]
    user = wrengr
[core]
    # Just to be sure.
    editor = vim
    # Chromium style demands we disable autocrlf.
    # TODO: do we want this everywhere else? Can we guard it to be
    # Chromium-only?
    autocrlf = false
    filemode = false
    whitespace = trailing-space,space-before-tab
    # TODO: we want something like this, but we don't want to use
    # ~/.gitignore per se, since that's likely to be the one in my
    # dotfiles repo, which ignores a bunch of homedir-specific stuff
    # we may not want to ignore elsewhere. So we should add some file
    # like ~/.gitconfig.ignore to the dotfiles repo, and then use that
    # one here:
    #excludesfile = '~/.gitignore'


[advice]
    # Disable `git status`'s "how to stage/unstage/add" hints
    statusHints = false
    # Disable `git push`'s hints about non-fastforward-able patches
    #pushNonFastForward = false
    # Others: pushUpdateRejected, pushNonFFCurrent, pushNonFFMatching, pushAlreadyExists, pushFetchFirst, pushNeedsForce, statusHints, statusUoption, commitBeforeMerge, resolveConflict, implicitIdentity, detachedHead, amWorkDir, rmHints, addEmbeddedRepo
[push]
    default = simple
#[pull]
#    ff = only
[merge]
    ff = only
# I don't actually like this exact setup, but the fact that we can
# do things like this is good to bear in mind, in case I come up with a
# particular command/flow that does capture my workflow.
#[merge]
#    tool = vimdiffnice
#[mergetool "vimdiffnice"]
#    cmd = vimdiff -c \"wincmd J\" -c \"0\" -c \"/<<<<<<< \" $MERGED $LOCAL $BASE $REMOTE
[diff]
    # TODO: consider installing and using JaneStreet's implementation
    # instead: <https://github.com/janestreet/patdiff>. It's a lot
    # nicer about how it colorizes things:
    # <http://neocontra.blogspot.com/2013/02/public-service-announcement-patdiff-is.html>
    # Or, consider using <https://github.com/so-fancy/diff-so-fancy>
    algorithm = patience
    # Use prefixes (i)ndex, (w)ork tree, (c)ommit, (o)bject. Rather
    # than the standard generic (a) (b). For example:
    # git diff                  # i vs w
    # git diff HEAD             # c vs w
    # git diff --cached         # c vs i
    # git diff HEAD:file1 file2 # o vs w
    mnemonicPrefix = true
[branch]
    # Have newly-created branches starting from a branch, set their
    # start point as upstream (as oppose to the default 'true' setting
    # where this only happens when the start point is a remote-tracking
    # branch). <http://grimoire.ca/git/config>
    autoSetupMerge = always
[log]
    # abbrevCommit = true
    mailmap = true


# TODO: consider also: <http://www.caliban.org/ruby/acoc.shtml>
# The documentation on what things have color names is hidden away
# in: <https://git-scm.com/docs/git-config>
# Also, cf: <https://stackoverflow.com/a/28256977/358069>
# Alas, `git config --get-regexp --name-only color.*` only shows the non-default ones!
[color]
    ui = true
    branch = auto
    diff = auto
    interactive = auto
    status = auto
    #grep, pager, decorate, showbranch
[color "branch"]
    # TODO: is there any way to colorize the hash (a la color.diff.commit)?
    current = magenta bold
    upstream = red bold
    local = green bold
    remote = blue bold
[color "decorate"]
    head = magenta bold
    branch = green bold
    remoteBranch = blue bold
    tag = yellow bold
    stash = red bold
    # <log-tree.c> also has a "grafted" color (default: bold blue),
    # but there's no way we can change that color from here.
[color "diff"]
    meta = yellow bold
    # N.B., color.diff.commit is used both for diff itself **but
    # also for git log**! In particular, it's the color that --oneline
    # will use! This seems to only be discoverable by looking at the
    # source code for <pretty.c>
    commit = yellow
    frag = magenta bold
    # Seems like "func" is everything else on the same line as "frag"...
    func = magenta
    old = red
    new = green
    whitespace = red reverse
#[color "grep"]
#    context =
#    filename =
#    function =
#    linenumber =
#    matchContext =
#    matchSelected =
#    selected =
#    separator =
#[color "interactive"]
#    prompt =
#    header =
#    help =
#    error =
[color "status"]
    branch = magenta bold
    added = yellow
    changed = green
    untracked = cyan
    #unmerged =


# There are ways of making 'pull --rebase' the default, but it seems
# to take a non-trivial amount of work; so I'm just using an alias
# 'pr' for now. One way to try to make 'pr' the default 'pull' is to
# set 'pull.rebase = true', another way is to set 'branch.autoSetupRebase
# = always', but neither of those seems to work quite right for me.
# In any case, however you do it, if you try a 'pr' and it has conflicts
# you need to manually resolve, then do 'rebase --continue' afterwards
# to finish it up.
# <http://randyfay.com/content/simpler-rebasing-avoiding-unintentional-merge-commits>
# <http://randyfay.com/content/rebase-workflow-git>


# TODO: cf., <http://nuclearsquid.com/writings/git-tricks-tips-workflows/>


# For more alias ideas, see:
# <http://noamlewis.wordpress.com/2012/05/21/my-git-aliases/>
# <http://durdn.com/blog/2012/11/22/must-have-git-aliases-advanced-examples/>
[alias]
    hw    = help --web
    # For more details on the files affected, try adding: --stat,
    # --numstat, --name-status, --name-only, --dirstat.
    # To only show N files, pass -N. Or consider: --since=2.weeks
    # Supposedly --graph defaults to --topo-order; but then why
    # does it not always look that way at work?
    # N.B., git-log picks up colors from color.diff. In particular,
    # the builtin --oneline will use color.diff.commit for the hash!
    lol   = log --graph --pretty=oneline --abbrev-commit --decorate
    # N.B., the %C(auto) color was introduced in git 1.8.3 (24 May 2013)
    # N.B., the meaning of %C(auto) for %h and %H is color.diff.commit
    # (whereas %t, %T, %p, and %P are all colorless). Whereas for
    # %d and %D is uses color.decorate
    #
    # TODO: maybe consider turning this format string into an alias
    # by setting pretty.<name> ?
    #
    # TODO: consider moving the %d to the end of the line? T'would
    # differ from lol, but would help keep the branch/tag info from
    # interfering with reading the commit subjects...
    #
    # BUG: unlike the lol alias (i.e., using --oneline) this doesn't
    # mix well with --stat etc. The docs say that --pretty=tformat:blah
    # (or --format=blah) is what --oneline uses to get "terminator
    # semantics" rather than the "separator semantics" of
    # --pretty=format:blah. But for some reason, using lola with
    # --stat etc introduces an additional blank line (with the
    # vertical bar from the --graph) before it prints the stats;
    # unline --oneline and hence lol.
    lola  = log --color --graph --pretty=tformat:'%C(auto)%h%Creset %Cgreen(%cr)%Creset %C(blue)<%aN>%Creset%C(auto)%d%Creset %s'
    # This one also shows stashes and abandoned branches/heads
    rofl  = "!git lol $(git rev-list -g --all)"
    # Show more details of the most recent patch:
    # (To show the diff, use `git show` or try `git diff --cached HEAD^`)
    top   = log --stat -1
    unpushed = log @{u}..
    st    = status --branch
    # What we really want most of the time.
    ci    = commit --patch
    # For when we're lazy or singleminded.
    ca    = commit --all
    # N.B., we do *not* pass the --all flag here! Instead we use --patch
    # to selectively choose changes.
    amend = commit --amend --patch
    # We use "oo" rather than the standard "co" to avoid typo issues vs "ci".
    oo    = checkout
    pr    = pull --rebase
    ra    = rebase --abort
    rc    = rebase --continue
    # AKA: commute the diff goddamnit!
    ro    = rebase --onto
    # For getting rebases to work when they cherry picked you, or similar.
    rs    = rebase --skip
    wdiff = diff --color-words
    # This will unrecord the most recent commit. N.B., you can also
    # use "~1" instead of "^" at the end; or "~N" to revert the
    # N most-recent commits. <http://stackoverflow.com/q/927358/358069>
    unrecord = reset --soft 'HEAD^'
    # Undo a `git reset`. N.B., '{1}' may not always be the one you
    # want; cf `git reflog` <http://stackoverflow.com/a/2531803/358069>
    unreset = reset 'HEAD@{1}'
    # Unstage some files. (Takes one or more files/paths)
    # * To unstage only some chunks, use `git reset -p --`
    unadd = reset --
    unadd-all = reset -- .
    # Revert (i.e., discard) all *unstaged* changes.
    # * To remove untracked files, use `git clean -df`
    # * To revert only some chunks, use `git checkout -p`
    # In all cases, you can give a specific file name instead of '.'
    # <http://stackoverflow.com/q/52704/358069>
    revert-all = checkout -- .
    # BUG: the second argument to `checkout -b` should be the
    # *remote* branch it tracks... I think. In any case, just passing
    # the second argument isn't enough to cause the new local-branch
    # to track the old local-branch (as we want for Chromium stuff).
    # Whence the additional call to `branch -u`.
    # For more info, cf:
    # <https://www.git-tower.com/learn/git/faq/track-remote-upstream-branch>
    # <https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches>
    # TODO: actually, the brokenness here may have something to do with
    # Chromium defining their own git_new_branch.py command.
    #new-branch = "!f(){ \
    #    old=\"`git rev-parse --abbrev-ref HEAD)\"; \
    #    git checkout -b \"$1\" \"$old\" ; \
    #    git branch --set-upstream-to=\"$old\"; \
    #    }; f"
    push-new-branch = push --set-upstream origin
    # TODO: a version of del-branch that automatically switches to
    # the upstream branch if we're on the branch to be
    # deleted. (Rather than just erroring out, as `branch -d` does.)
    # N.B., can use -D as a shorthand for -d --force
    del-branch = branch -d
    push-del-branch = push origin --delete
    # List branches in order last modified:
    # (N.B., for-each-ref doesn't support --color nor %cr)
    # What fields are supported: <http://stackoverflow.com/a/21868228>
    # HT: <https://gist.github.com/mwhite/6887990>
    # TODO: is there a way to combine this info with the "mb" and "bv" info?
    # TODO: is there any way to color this like we do for the others?
    lm = "!git for-each-ref \
        --sort='-authordate' \
        --format='%(authordate:short)%09%(objectname:short)%09%(refname)' \
        refs/heads | sed -e 's@refs/heads/@@'"
    # Show the most recent tag
    lt = describe --tags --abbrev=0
    # List the modification date of files in the current directory (in order of file name).
    # BUG: there's some kind of typo here re the quoting. What's wrong?
    #lslm = "!git ls-tree -z --name-only HEAD | xargs -0 -n1 -I{} -- git log -1 --format='%aI {}' {} | sed -re 's/^([^T]+)T\S+(.*)/\1\2/'"
    bv = branch -vv
    # HT: <https://gist.github.com/pksunkara/988716>
    whois = "!sh -c 'git log -i -1 --pretty=\"format:%an <%ae>%n\" --author=\"$1\"' -"
    # HT: <https://gist.github.com/mwhite/6887990>
    aliases = "!git config -l | grep alias | cut -c 7-"
    # Get rid of dangling patches in the repo.
    gc-for-reals = "!git reflog expire --expire=now --all && git gc --prune=now"
    # HT: <http://durdn.com/blog/2012/11/22/must-have-git-aliases-advanced-examples/>
    assume = update-index --assume-unchanged
    unassume = update-index --no-assume-unchanged
    assumed = "!git ls-files -v | grep ^h | cut -c 3-"
    unassume-all = "!git assumed | xargs git update-index --no-assume-unchanged"
    assume-all = "!git st -s | awk {'print $2'} | xargs git assume"
    # Chromium/Google-only things.
    # TODO: how to guard these so they don't break on my other systems?
    # N.B., `git map` comes from the same place as `git map-branches`
    # (I think), so it's also Chromium-specific.
    mb = map-branches
    ru = rebase-update


# Trying to solve this problem
# <http://stackoverflow.com/q/11403407>
# <http://stackoverflow.com/a/6565661>
# <http://stackoverflow.com/a/5343146>
#[credential "https://github.iu.edu/"]
#    username = wrengr

# TODO: is there a way to set this http info differently for various
# hosts, while using the same file (so I don't need to postprocess
# the stuff in my dotfiles repo)?
#[http]
#    cookiefile = /usr/local/google/home/wrengr/.gitcookies

# Speed up pulling from repos by pulling from the read-only version
# (so you don't need to authenticate) but can still push to the
# real one.
# TODO: do we actually want/need to do this?
# <http://billiob.net/blog/20110410_git_pushinsteadof.html>
# <https://www.kernel.org/pub/software/scm/git/docs/git-config.html>
#[url "git@github.com:"]
#    pushInsteadOf = https://github.com/
#    pushInsteadOf = git://github.com/

# For git-on-borg at google. The way the config looks is confusing; what
# this means is whenever we type "gob:" that'll get rewritten to the url.
#[url "sso://user/wrengr/"]
#    insteadOf = gob:
