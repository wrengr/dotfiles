#!/usr/bin/env perl
# An enhanced version of `git branch -vv`
# wren gayle romano <wrengr@google.com>             ~ 2018.02.05
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# N.B., by naming this as we have and having it on our path, this
# script will be automagically run if someone says `git bb`;
# no aliases required!

use warnings;
use strict;

# TODO: parse input flags, and print usage info.
# TODO: configuration options for:
# * more/less verbosity
# * yes/no color output
# * show remote-tracking branches too (a la git-branch's -a/--all)
# * how to sort the tree (by last-modified, by name, by "weight"
#   so that it's mostly right/bottom branching,...)
# * filtering the tree (by last-modified, etc), maybe? cf.,
#   <https://github.com/MarkLodato/scripts/blob/master/git-recent-branches>


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~ Shelling out

# A variant of backticks with explicit tokenization, for better
# security/correctness and to avoid quotation hell.
sub backticks {
    open my $FH, '-|', @_
        or die "Couldn't fork @_: $!\n";

    # HACK: we assume the output is a single line. If it isn't,
    # then when we close the file handle, that'll send SIGPIPE to
    # the child process. If the child can't handle SIGPIPE, then
    # when it dies it'll kill us too (via the checks below).
    my $stdout = <$FH>;

    if (close $FH) { # Both the syscall and the child process exit cleanly.
        if (defined $stdout) { # Avoid warnings about chomping undef.
            chomp $stdout; # This is crucial!
            return $stdout;
        } else {
            # HACK: This isn't inherently bad, just never what we
            # want for our particular use cases.
            die "No output from @_\n";
        }
    } elsif ($!) { # The syscall itself failed, rather than the child process.
        die "Couldn't close pipe to @_: $!\n";
    } elsif ($? == -1) {
        # Should this case obtain, then circumstances are prolly such
        # that the open syscall would've failed before we ever even
        # got to the close syscall; thus making this branch unreachable.
        # But whatevs; better safe than sorry.
        die "Couldn't execute @_: $!\n";
    } elsif ($? & 127) {
        die sprintf "Signal %d killed @_ (%s coredump)\n",
            ($? & 127),  ($? & 128) ? 'with' : 'without';
    } else {
        my $exit = $? >> 8; # extract the actual exit-code.
        if ($exit) {
            die "Exited with failure @_: $exit\n";
        } else {
            # The close syscall succeeded, the child process exited
            # cleanly, and the child's exit code was zero, so...
            die "wtf? @_\n";
        }
    }
}

# N.B., since we're using $Git as the first argument to backticks,
# it's especially crucial that we chomp here.
my $Git = backticks 'which', 'git';


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~ Color configuration

# TODO: is there any way to make this faster? i.e., to get all the
# colors in one go, rather than firing off a subprocess for each
# color? Or if that's impossible, then maybe fill in the table lazily
# based on the colors we actually use?

# N.B., for getting the color reset we really do need that empty argument.
my $Reset = backticks $Git, 'config', '--get-color', '', 'reset';
my %Color;
$Color{$_} = backticks $Git, 'config', '--get-color', $_
    foreach
    ( 'color.branch.current'
    , 'color.branch.upstream'
    , 'color.branch.local'
    , 'color.branch.remote'
    # 'color.branch.plain'          # TODO: Could be used for our "no color"?
    # 'color.decorate.head'         # Should equal 'color.branch.current' imo.
    # 'color.decorate.branch'       # Should equal 'color.branch.local' imo.
    # 'color.decorate.remoteBranch' # Should equal 'color.branch.remote' imo.
    # 'color.decorate.tag'          # TODO: would this ever be helpful?
    # 'color.decorate.stash'        # TODO: would this ever be helpful?
    , 'color.diff.commit'
    , 'color.diff.old'              # We use this for tracking-behind
    , 'color.diff.new'              # we use this for tracking-ahead
    # 'color.diff.plain'            # TODO: Could be used for our "no color"?
    );

sub colorize {
    my ($colorname, $string) = @_;
    # TODO: guard against unknown/unexpected $colorname.
    # TODO: add config stuff to handle dis-/enabling color.
    return $Color{$colorname} . $string . $Reset;
}


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~ Gather branch information

# TODO: when using real git and so "upstream" is always a remote branch,
#       is there a way to get the actual parentage relation?
# TODO: for use with git5, also get info about whether the exported
#       version is up to date. Consider using something like:
#       > git rev-list --left-right ${thisBranch}...${thatBranch}
#       to get the ahead/behind info. (cf., <https://gist.github.com/kd35a/7924799> and <https://github.com/bill-auger/git-branch-status/>)
# TODO: also get the %(subject), a la `git branches -vv`. (Make this
#       optional, since I almost never care, and it almost always linewraps)
# TODO: anything else we want from <https://stackoverflow.com/a/21868228>?
#       Maybe the relative date and author/committer name, like lola has?
# TODO: define a single structure which combines this information with
#       the color info, so that we don't need to manually keep the
#       order of things in sync.
my $BranchInfoFormat = join '%09', # Tab should be a safe delimiter to use.
    '%(refname:short)',    # The name of the branch in question.
    '%(objectname:short)', # The git hash that branch currently points to.
    '%(authordate:short)', # The YYYY-MM-DD that hash was authored.
    # '%(push:short)',     # Where `git push` goes (may differ from upstream).
    '%(upstream:short)',   # Short name of parent branch, for pretty printing.
    '%(upstream:remotename)', # The repo name where $upstream lives, if it's remote.
    '%(upstream:track,nobracket)'; # The "gone/ahead/behind" string.
open my $FH, '-|',
    $Git, 'for-each-ref', "--format=$BranchInfoFormat", 'refs/heads'
        or die "Can't run git for-each-ref: $!";
my %BranchInfo = ();
while (<$FH>) {
    chomp;
    my ($branch, $hash, $authordate, $upstream, $remote, $tracking) = split "\t";
    # TODO: move the splitting/parsing of $tracking to here.
    # TODO: also get info about the git5/citc refname, so we can print our tracking info relative to that too. (or at least print a boolean about whether the citc is up to date or no.)
    $BranchInfo{$branch} =
        { 'branch'     => $branch
        , 'hash'       => $hash
        , 'authordate' => $authordate
        , 'upstream'   => $upstream
        , 'remote'     => $remote
        , 'tracking'   => $tracking
        };
}
# TODO: more verbose error messages for unpacking $? into its component parts.
close $FH or die "Couldn't close pipe: $! $?";


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~ Determine the root set (and other sets).
my %Gone;     # Treated as a set.
my %Remote;   # Treated as a set.
my %Roots;    # Treated as a set.
my %Children; # A hash of (lists treated as) sets.
while (my ($child, $info) = each %BranchInfo) {
    die "No info for branch $child\n" unless $info;
    my $parent = ${$info}{'upstream'};

    unless (exists $BranchInfo{$parent}) {
        # If the parent isn't local, it must be a root.
        # (Regardless of whether it's remote or gone.)
        $Roots{$parent} = 1;

        # TODO: not sure this'll end up doing the right thing for
        # standard git repos (i.e., when not using git5). That is,
        # typically we have every local branch be tracking the remote
        # version of that same branch; but that means we'll end up
        # with a flat "tree" rather than printing out the appropriate
        # dependency tree. The Chromium depot-tools version tries calling:
        # > git rev-parse --abbrev-ref --symbolic-full-name $child@{upstream}
        # before giving up and putting things into %Gone. But that
        # doesn't quite work for me...
        if (${$info}{'remote'}) {
            $Remote{$parent} = 1;
        } else {
            # The upstream is neither local nor remote, so it must be gone.
            $Gone{$parent} = 1;
        }
    }

    # Include ourself among our parent's children.
    push @{$Children{$parent}}, $child;
}


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~ Pretty-print branches

my $HEAD = backticks $Git, 'rev-parse', '--abbrev-ref', 'HEAD';

sub colorizeBranch {
    my ($branch) = @_;
    my $colorname;
    if (not $branch) {
        # This case is taken from Chromium depot-tools' git-map-branches,
        # though I've never encountered it myself...
        $colorname = 'color.branch.upstream'; # HACK: What color should this be?
        $branch = '{NONE}';
    } elsif (exists $Gone{$branch}) {
        $colorname = 'color.branch.upstream'; # HACK: What color should this be?
        $branch = "{${branch}:GONE}";
    } elsif (exists $Remote{$branch}) {
        $colorname = 'color.branch.remote';
    } elsif ($branch eq $HEAD) {
        # TODO: need to generalize this test to also catch when the
        # current branch (i.e., according to git, not whatever $branch
        # happened to be passed as an argument) is the literal string
        # 'HEAD' (according to what the depot-tools version does; though
        # I've never encountered that issue), or also being some other
        # branch which happens to point at the same hash as $HEAD does.
        $colorname = 'color.branch.current';
        # TODO: iff color is disabled, then we may want to add a
        # prefix/suffix to $branch, like `git branch -vv` and Chromium
        # depot-tools' git-map-branches.
    } else {
        $colorname = 'color.branch.local';
    }
    return colorize $colorname, $branch;
}

# TODO: we ought to break this out into a more general string-builder
# sort of thing. Especially since we have a notion of columns and
# padding them to align.
sub prettyPrintBranch {
    my ($branch, $paddingWidth, $treeDepth) = @_;
    my $columnSeparator = '  ';

    # HACK: We want to print the (putative) branch, even if it has no info.
    print '',
        ('  ' x $treeDepth),
        colorizeBranch($branch),
        # TODO: update this padding to work correctly vis-a-vis munging $branch
        (' ' x ($paddingWidth - 2*$treeDepth - length $branch)),
        $columnSeparator;

    # TODO: clean up this guarding.
    if (exists $BranchInfo{$branch}) {
        my $info = $BranchInfo{$branch}; # Cache the hash lookup.
        # TODO: avoid the need for this caching by passing it in,
        # via the "while (my ($k,$v) = each %h)" idiom in lieu of our
        # current foreach.

        my $tracking = ${$info}{'tracking'};
        if (not defined $tracking) {
            # TODO: actually handle this case!
            die "Undefined tracking info for branch $branch\n";
        } elsif ($tracking eq 'gone') {
            # TODO: want a color here! but which one? Would
            # 'color.diff.whitespace' be appropriate, or
            # 'color.status.untracked' or... what?
        } else {
            my $orig = $tracking;
            $tracking = '';
            if ($orig =~ m/ahead\s+(\d+)/) {
                $tracking .= colorize('color.diff.new', "+$1");
            }
            if ($orig =~ m/behind\s+(\d+)/) {
                $tracking .= ', ' if $tracking;
                $tracking .= colorize('color.diff.old', "-$1");
            }
        }
        # TODO: if $tracking was originally the empty string, then
        # maybe we should print something like '[=]'

        # Given the visible tree structure, there's no benefit to printing
        # ${$info}{'upstream'}, so we just add the brackets here.
        $tracking = "[$tracking]" if $tracking ne '';

        print '',
            colorize('color.diff.commit', ${$info}{'hash'}),
            $columnSeparator,
            ${$info}{'authordate'},
            $columnSeparator,
            $tracking;
    }
    print "\n";
}


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~ Recursively construct and traverse the tree.

# TODO: must adjust this to incorporate the indentation level of the
# tree. We want to make sure that deep branches don't overflow due to
# indentation; also would be nice to not have excessive padding whenever
# the only long branch names are shallow.
my $MaxBranchLength = 0;
foreach my $branch (keys %BranchInfo) {
    my $length = length $branch;
    $MaxBranchLength = $length if $length > $MaxBranchLength;
}

# Hylomorphism to unfold the tree from %Roots and then immediately consume
# it by calling &prettyPrintBranch on each node. To simplify the separation
# of the unfold and the prettyprinting we use a poor-man's recursion to
# build the tree from a stack. Of course, this means we never really have
# the tree in hand; which will make it hard to add support for flexible
# sorting/ordering.
my @BranchQueue = sort keys %Roots;
my $Depth = 0;
while (@BranchQueue) {
    my $branch = shift @BranchQueue;
    if ($branch) {
        prettyPrintBranch($branch, $MaxBranchLength, $Depth);

        # TODO: the depot-tools version pops the branch out of the
        # hash... why? is that necessary for us?
        if (exists $Children{$branch}) {
            ++$Depth;
            unshift @BranchQueue, ''; # HACK: sentinel for decrementing $Depth.
            unshift @BranchQueue, sort @{$Children{$branch}};
            # TODO: decrement $Depth once those branches are done.
        }
    } else {
        --$Depth; # Interpet the sentinels.
    }
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ fin.
exit 0;
__END__
