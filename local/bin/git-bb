#!/usr/bin/env perl
# An enhanced version of `git branch -vv`
# wren gayle romano <wrengr@google.com>             ~ 2018.02.05
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# N.B., by naming this as we have and having it on our path, this
# script will be automagically run if someone says `git bb`;
# no aliases required!

use warnings;
use strict;

# TODO: configuration options for:
# * more/less verbosity (both what branch info is printed, and debugging info)
# * disable/enable color
# * show remote-tracking branches too (a la git-branch's -a/--all)
# * how to sort the tree (by last-modified, by name, by "weight"
#   so that it's mostly right/bottom branching,...)
# * filtering the tree (by last-modified, etc), maybe? cf.,
#   <https://github.com/MarkLodato/scripts/blob/master/git-recent-branches>


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~ Shelling out

# Open a pipe and pass it to a block, being sure to close it and
# provide detailed error messages.
#
# TODO: add caller info to the `die` messages, to ease debuging.
sub withPipe {
    # We put the block at the end (rather than using prototypes to
    # avoid the need for the `sub` keyword) because the block is
    # likely to be longer than the command, so this way looks better
    # overall.
    my $block = pop;

    # Require the command to be explicitly tokenized, to minimize
    # problems about correctness, security, and quotation hell.
    open my $FH, '-|', @_
        or die "Couldn't fork @_: $!\n";

    my $ret = &$block($FH);

    # N.B., it's the `close` call itself which sets both $! and $?
    if (close $FH) { # Both the syscall and the child process exit cleanly.
        # If the continuation returned anything, forward that along to callers.
        return $ret;
    } elsif ($!) { # The syscall itself failed, rather than the child process.
        die "Couldn't close pipe to @_: $!\n";
    } elsif ($? == -1) {
        # Should this case obtain, then circumstances are prolly such
        # that the open syscall would've failed before we ever even
        # got to the close syscall; thus making this branch unreachable.
        # But whatevs; better safe than sorry.
        die "Couldn't execute @_: $!\n";
    } elsif ($? & 127) {
        my $signal = $? & 127;
        my $core   = ($? & 128) ? "with" : "without";
        die "Signal $signal killed @_ ($core coredump)\n";
    } elsif ($? >> 8) { # extract the actual exit-code.
        my $exit = $? >> 8;
        die "Exited with failure @_: $exit\n";
    } else {
        # The close syscall succeeded, the child process exited
        # cleanly, and the child's exit code was zero, so...
        die "wtf? @_\n";
    }
}

# A variant of backticks with explicit tokenization, for better
# security/correctness and to avoid quotation hell.
sub backticks {
    return withPipe @_, sub {
        my $FH = shift;

        # HACK: we assume the output is a single line. If it isn't,
        # then when we close the file handle, that'll send SIGPIPE to
        # the child process. If the child can't handle SIGPIPE, then
        # when it dies it'll kill us too (via the checks below).
        my $stdout = <$FH>;

        if (defined $stdout) { # Avoid warnings about chomping undef.
            chomp $stdout; # This is crucial!
            return $stdout;
        } else {
            # This isn't inherently bad, just never what we want
            # for our particular use cases.
            die "No output from @_\n";
        }
    };
}

# N.B., since we're using $Git as the first argument to backticks,
# it's especially crucial that we chomp here.
my $Git = backticks 'which', 'git';


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~ Color configuration

# TODO: is there any way to make this faster? i.e., to get all the
# colors in one go, rather than firing off a subprocess for each
# color? Or if that's impossible, then maybe fill in the table lazily
# based on the colors we actually use?

# N.B., for getting the color reset we really do need that empty argument.
my $Reset = backticks $Git, 'config', '--get-color', '', 'reset';
my %Color;
$Color{$_} = backticks $Git, 'config', '--get-color', $_
    foreach
    ( 'color.branch.current'
    , 'color.branch.upstream'
    , 'color.branch.local'
    , 'color.branch.remote'
    # 'color.branch.plain'          # TODO: Could be used for our "no color"?
    # 'color.decorate.head'         # Should equal 'color.branch.current' imo.
    # 'color.decorate.branch'       # Should equal 'color.branch.local' imo.
    # 'color.decorate.remoteBranch' # Should equal 'color.branch.remote' imo.
    # 'color.decorate.tag'          # TODO: would this ever be helpful?
    # 'color.decorate.stash'        # TODO: would this ever be helpful?
    , 'color.diff.commit'
    , 'color.diff.old'              # We use this for tracking-behind
    , 'color.diff.new'              # we use this for tracking-ahead
    # 'color.diff.plain'            # TODO: Could be used for our "no color"?
    );

sub colorize {
    my ($colorname, $string) = @_;
    # TODO: guard against unknown/unexpected $colorname.
    # TODO: add config stuff to handle dis-/enabling color.
    return $Color{$colorname} . $string . $Reset;
}


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~ Gather branch information

# TODO: when using real git and so "upstream" is always a remote branch,
#       is there a way to get the actual parentage relation?
# TODO: for use with git5, also get info about whether the exported
#       version is up to date. Consider using something like:
#       > git rev-list --left-right --count ${thisBranch}...${thatBranch}
#       to get the ahead/behind info. (cf., <https://gist.github.com/kd35a/7924799> and <https://github.com/bill-auger/git-branch-status/>)
# TODO: also get the %(subject), a la `git branch -vv`. (Make this
#       optional, since I almost never care, and it almost always linewraps)
# TODO: anything else we want from <https://stackoverflow.com/a/21868228>?
#       Maybe the relative date and author/committer name, like lola has?
# TODO: define a single structure which combines this information with
#       the color info, so that we don't need to manually keep the
#       order of things in sync.
my $BranchInfoFormat = join '%09', # Tab should be a safe delimiter to use.
    '%(refname:short)',    # The name of the branch in question.
    '%(objectname:short)', # The git hash that branch currently points to.
    '%(authordate:short)', # The YYYY-MM-DD that hash was authored.
    # '%(push:short)',     # Where `git push` goes (may differ from upstream).
    '%(upstream:short)',   # Short name of parent branch, for pretty printing.
    '%(upstream)',         # Long version, for detecting remote branches.
    '%(upstream:track,nobracket)'; # The "gone/ahead/behind" string.

my %BranchInfo = ();
withPipe $Git, 'for-each-ref', "--format=$BranchInfoFormat", 'refs/heads',
    sub {
        my $FH = pop;
        while (<$FH>) {
            chomp;
            my ($branch, $hash, $authordate, $upstreamShort, $upstreamLong, $tracking) = split "\t";

            # If (and only if!!) the upstream branch is a remote-tracking
            # branch, then set $remote to the name of the remote repo
            # where that branch lives. This differs from '%(upstream:remotename)'
            # (introduced in git-2.16) which will sometimes return '.'
            # as the name of the "remote" repo when the branch is in fact
            # local.
            # N.B., as written, local branches will have $remote
            # be undefined, rather than being a defined but false
            # value like the empty string.
            my ($remote) = $upstreamLong =~ m@^refs/remotes/([^/]+)@;

            # TODO: move the splitting/parsing of $tracking to here.

            # TODO: also get info about the git5/citc refname, so
            # we can print our tracking info relative to that too.
            # (or at least print a boolean about whether the citc is
            # up to date or no.)
            $BranchInfo{$branch} =
                { 'branch'     => $branch
                , 'hash'       => $hash
                , 'authordate' => $authordate
                , 'upstream'   => $upstreamShort
                , 'remote'     => $remote
                , 'tracking'   => $tracking
                };
        }
    };


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~ Determine the root set (and other sets).
my %Gone;     # Treated as a set.
my %Remote;   # Treated as a set.
my %Roots;    # Treated as a set.
my %Children; # A hash of (lists treated as) sets.
while (my ($child, $info) = each %BranchInfo) {
    die "No info for branch $child\n" unless $info;
    my $parent = ${$info}{'upstream'};

    unless (exists $BranchInfo{$parent}) {
        # If the parent isn't local, it must be a root.
        # (Regardless of whether it's remote or gone.)
        $Roots{$parent} = 1;

        # TODO: not sure this'll end up doing the right thing for
        # standard git repos (i.e., when not using git5). That is,
        # typically we have every local branch be tracking the remote
        # version of that same branch; but that means we'll end up
        # with a flat "tree" rather than printing out the appropriate
        # dependency tree. The Chromium depot-tools version tries calling:
        # > git rev-parse --abbrev-ref --symbolic-full-name $child@{upstream}
        # before giving up and putting things into %Gone. But that
        # doesn't quite work for me...
        if (${$info}{'remote'}) {
            $Remote{$parent} = 1;
        } else {
            # The upstream is neither local nor remote, so it must be gone.
            $Gone{$parent} = 1;
        }
    }

    # Include ourself among our parent's children.
    push @{$Children{$parent}}, $child;
}


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~ Pretty-print branches

my $HEAD = backticks $Git, 'rev-parse', '--abbrev-ref', 'HEAD';

sub colorizeBranch {
    my ($branch) = @_;
    my $colorname;
    if (not $branch) {
        # This case is taken from Chromium depot-tools' git-map-branches,
        # though I've never encountered it myself...
        $colorname = 'color.branch.upstream'; # HACK: What color should this be?
        $branch = '{NONE}';
    } elsif (exists $Gone{$branch}) {
        $colorname = 'color.branch.upstream'; # HACK: What color should this be?
        $branch = "{${branch}:GONE}";
    } elsif (exists $Remote{$branch}) {
        $colorname = 'color.branch.remote';
    } elsif ($branch eq $HEAD) {
        # TODO: need to generalize this test to also catch when the
        # current branch (i.e., according to git, not whatever $branch
        # happened to be passed as an argument) is the literal string
        # 'HEAD' (according to what the depot-tools version does; though
        # I've never encountered that issue), or also being some other
        # branch which happens to point at the same hash as $HEAD does.
        $colorname = 'color.branch.current';
        # TODO: iff color is disabled, then we may want to add a
        # prefix/suffix to $branch, like `git branch -vv` and Chromium
        # depot-tools' git-map-branches.
    } else {
        $colorname = 'color.branch.local';
    }
    return colorize $colorname, $branch;
}

# TODO: we ought to break this out into a more general string-builder
# sort of thing. Especially since we have a notion of columns and
# padding them to align.
sub prettyPrintBranch {
    my ($branch, $paddingWidth, $treeDepth) = @_;
    my $columnSeparator = '  ';

    # HACK: We want to print the (putative) branch, even if it has no info.
    print '',
        ('  ' x $treeDepth),
        colorizeBranch($branch),
        # TODO: update this padding to work correctly vis-a-vis munging $branch
        (' ' x ($paddingWidth - 2*$treeDepth - length $branch)),
        $columnSeparator;

    # TODO: clean up this guarding.
    if (exists $BranchInfo{$branch}) {
        my $info = $BranchInfo{$branch}; # Cache the hash lookup.
        # TODO: avoid the need for this caching by passing it in,
        # via the "while (my ($k,$v) = each %h)" idiom in lieu of our
        # current foreach.

        my $tracking = ${$info}{'tracking'};
        if (not defined $tracking) {
            # TODO: actually handle this case!
            die "Undefined tracking info for branch $branch\n";
        } elsif ($tracking eq 'gone') {
            # TODO: want a color here! but which one? Would
            # 'color.diff.whitespace' be appropriate, or
            # 'color.status.untracked' or... what?
        } else {
            my $orig = $tracking;
            $tracking = '';
            if ($orig =~ m/ahead\s+(\d+)/) {
                $tracking .= colorize('color.diff.new', "+$1");
            }
            if ($orig =~ m/behind\s+(\d+)/) {
                $tracking .= ', ' if $tracking;
                $tracking .= colorize('color.diff.old', "-$1");
            }
        }
        # TODO: if $tracking was originally the empty string, then
        # maybe we should print something like '[=]'

        # Given the visible tree structure, there's no benefit to printing
        # ${$info}{'upstream'}, so we just add the brackets here.
        $tracking = "[$tracking]" if $tracking ne '';

        print '',
            colorize('color.diff.commit', ${$info}{'hash'}),
            $columnSeparator,
            ${$info}{'authordate'},
            $columnSeparator,
            $tracking;
    }
    print "\n";
}


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~ Recursively construct and traverse the tree.

# Hylomorphism to unfold the tree from %Roots and then immediately consume
# it by calling &prettyPrintBranch on each node. To simplify the separation
# of the unfold and the prettyprinting we use a poor-man's recursion to
# build the tree from a stack. Of course, this means we never really have
# the tree in hand; which will make it hard to add support for flexible
# sorting/ordering.
sub walkTree (&) {
    my ($visitor) = @_;

    my @queue = sort keys %Roots;
    my $depth = 0;
    while (@queue) {
        my $branch = shift @queue;
        if ($branch eq '') {
            --$depth; # Interpet the sentinels.
        } else {
            &$visitor($depth, $branch);

            if (exists $Children{$branch}) {
                ++$depth;
                unshift @queue, ''; # HACK: sentinel for decrementing $Depth.
                unshift @queue, sort @{$Children{$branch}};
            }
        }
    }
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~ Pretty print the tree.

# First walk the tree to get the maximum branch length for column
# padding. We don't simply iterate over the keys of %BranchInfo because
# that would make it difficult to incorporate the depth adjustment.
#
# TODO: We'd really rather get the length directly from &prettyPrintBranch,
# so that we can properly handle %Gone munging as well. Alas, there
# seems no clean way to do that, since we'd need to make sure not to
# count the colorizing control characters as part of the string length.
my $MaxBranchLength = 0;
walkTree {
    my ($depth, $branch) = @_;
    my $length = 2 * $depth + length $branch;
    $MaxBranchLength = $length if $length > $MaxBranchLength;
};

# Then walk it again to print it out.
# TODO: now that we've factored out &walkTree, we can/should prolly
# (re)inline &prettyPrintBranch here.
walkTree {
    my ($depth, $branch) = @_;
    prettyPrintBranch($branch, $MaxBranchLength, $depth);
};

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ fin.
exit 0;
__END__
