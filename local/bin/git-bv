#!/usr/bin/env perl
# An enhanced version of `git branch -vv`
# wren gayle romano <wrengr@x.com>                  ~ 2017.07.01
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# N.B., by naming this as we have and having it on our path, this
# script will be automagically run if someone says `git bv`;
# no aliases required!

use warnings;
use strict;

# TODO: parse input flags, and print usage info.
# TODO: configuration options for:
# * more/less verbosity
# * yes/no color output
# * show remote-tracking branches too? (a la git-branch's --all)
# * how to sort the tree (by last-modified, by name, by "weight" so that it's mostly right/bottom branching,...)

# TODO: inline this where appropriate in order to get better diagnostics
# about what command we were trying to run when this exploded. (and/or
# take the command in as an argument instead)
sub getExitCode {
    if ($? == -1) {
        die "failed to execute: $!\n";
    } elsif ($? & 127) {
        die sprintf "child died with signal %d, %s coredump\n",
            ($? & 127),  ($? & 128) ? 'with' : 'without';
    } else {
        return ($? >> 8);
    }
}

my $GIT = `which git`;
die "Couldn't locate git" unless 0 == getExitCode();
chomp $GIT; # N.B., this is crucial!

# TODO: is there any way to make this faster? i.e., to get all the colors in one go, rather than firing off a subprocess for each color? Or if that's impossible, then maybe fill in the table lazily based on the colors we actually use?
my %color = (
    'color.branch.current' => '',
    'color.branch.upstream' => '',
    'color.branch.local' => '',
    'color.branch.remote' => '',
    'color.branch.plain' => '', # Could be used for our "no color"?
    'color.decorate.head' => '',
    'color.decorate.branch' => '', # Should equal 'color.branch.local' imo.
    'color.decorate.remoteBranch' => '', # Should equal 'color.branch.remote' imo.
    'color.decorate.tag' => '',
    'color.decorate.stash' => '',
    'color.diff.commit' => '',
    'color.diff.old' => '', # We use this for how far behind we are
    'color.diff.new' => '', # we use this for how far ahead we are
    'color.diff.plain' => '', # Could be used for our "no color"?
);
foreach my $colorname (keys %color) {
    # TODO: sanitize away the backticks to avoid the call to sh.
    my $code = `$GIT config --get-color $colorname`;
    die "Couldn't get color $colorname" unless 0 == getExitCode();
    chomp $code;
    $color{$colorname} = $code;
}
# TODO: sanitize away the backticks to avoid the call to sh.
my $reset = `$GIT config --get-color '' reset`;
die "Couldn't get color reset" unless 0 == getExitCode();
chomp $reset;


# TODO: sanitize away the backticks to avoid the call to sh.
my $HEAD = `$GIT rev-parse --abbrev-ref HEAD`;
die "Couldn't get HEAD" unless 0 == getExitCode();
chomp $HEAD; # N.B., this is crucial!

sub verifyBranch {
    system($GIT, 'show-ref', '--quiet', '--verify', '--', "refs/heads/$_[0]");
    # "\033[1;31m${0##*/}:\033[0m \033[1mNot a valid branch:\033[0m \033[1;33m$CHILD\033[0m"
    return 0 == getExitCode();
}

# TODO: when using real git and so "upstream" is always a remote branch,
# is there a way to get the actual parentage relation?
# TODO: for use with git5, also get info about whether the exported versionis up to date.
# TODO: also get the %(subject), a la `git bv`. (Make this optional, since I almost never care, and it almost always linewraps)
# TODO: anything else we want from <https://stackoverflow.com/a/21868228>? Maybe the relative date and author/committer name, like lola has?
# TODO: define a single structure which combines this information with thw color info, so that we don't need to manually keep the order of things in sync.
my $REFS_FORMAT = join '%09',
    '%(refname:short)',
    '%(objectname:short)', # The git hash.
    '%(authordate:short)', # YYYY-MM-DD
    # '%(push:short)', # "the local ref which represents the @{push} location for the refname" ??? what is a @{push}?
    '%(upstream:short)',
    '%(upstream:track,nobracket)'; # the string "gone", or (join ', ', "ahead \d+", "behind \d+")
open my $FH, '-|',
    $GIT, 'for-each-ref', "--format=$REFS_FORMAT", "refs/heads"
        or die "Can't run git for-each-ref: $!";
my %parentage = ();
my %branches = ();
while (<$FH>) {
    chomp;
    my ($branch, $hash, $authordate, $upstream, $tracking) = split "\t";
    $parentage{$upstream}{$branch} = 1;
    $branches{$branch} = [$hash, $authordate, $upstream, $tracking];
}
close $FH or die "Couldn't close pipe: $! $?";


# TODO: once we print things as a tree, adjust this to incorporate the indentation level.
my $maxBranchLength = 0;
foreach my $branch (sort keys %branches) {
    my $length = length $branch;
    $maxBranchLength = $length if $length > $maxBranchLength;
}

# TODO: actually print as a tree
foreach my $branch (sort keys %branches) {
    my $tracking = $branches{$branch}[3];
    if ($tracking eq 'gone') {
        # TODO: want a color here! but which one? Would 'color.diff.whitespace' be appropriate, or 'color.status.untracked' or... what?
    } else {
        my $orig = $tracking;
        $tracking = '';
        if ($orig =~ m/ahead\s+(\d+)/) {
            $tracking .= $color{'color.diff.new'} . 'ahead ' . $1 . $reset;
        }
        if ($orig =~ m/behind\s+(\d+)/) {
            $tracking .= ', ' if $tracking;
            $tracking .= $color{'color.diff.old'} . 'behind ' . $1 . $reset;
        }
    }

    print '',
        ($branch eq $HEAD
            ? $color{'color.decorate.head'} # or 'color.branch.current' ?
            : $color{'color.decorate.branch'}), # or 'color.branch.local'?
        $branch,
        $reset,
        (' ' x ($maxBranchLength - length $branch)),
        ' ',
        $color{'color.diff.commit'},
        $branches{$branch}[0], # hash
        $reset,
        ' ',
        # $color{...},
        $branches{$branch}[1], # authordate
        # $reset,
        ' [',
        # TODO: should we pad this too?
        $color{'color.branch.upstream'}, # or color.branch.{local,remote} ?
        $branches{$branch}[2], # upstream
        $reset,
        ': ',
        $tracking,
        "]\n";
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ fin.
exit 0;
__END__
