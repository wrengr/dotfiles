-- -*- mode: haskell; -*-

----------------------------------------------------------------
-- For more inspiration, see:
-- <http://www.haskell.org/pipermail/haskell-cafe/2007-September/032260.html>
-- <http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/dot-squashed.ghci>
-- <http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/dot-squashed.ghci641>
-- <http://www.haskell.org/haskellwiki/Ghci>
-- <http://hackage.haskell.org/package/ghc-paths>
-- <http://hackage.haskell.org/package/goa>


----------------------------------------------------------------
-- * Helpful commands and tool integration

-- :. <file>             Source commands from <file>
:def . readFile

-- :pwd                  Print the working directory
:def pwd \_ -> return "System.Directory.getCurrentDirectory >>= putStrLn"

-- :ls [...]             Get a directory listing
:def ls \str -> return (":!ls " ++ str)

-- :stdout <var> <cmd>    Execute <cmd>, redirecting stdout to <var>
--     Named thus to avoid conflict with :r for :reload, etc.
:{
:def stdout \varcmd ->
        case break Data.Char.isSpace varcmd of
        { (var, _:cmd) ->
            return $ unlines
                [ ":set -fno-print-bind-result"
                , "tmp   <- System.Directory.getTemporaryDirectory"
                , "(f,h) <- System.IO.openTempFile tmp \"ghci\""
                , "sto   <- GHC.Handle.hDuplicate System.IO.stdout"
                , "GHC.Handle.hDuplicateTo h System.IO.stdout"
                , "System.IO.hClose h"
                , cmd
                , "GHC.Handle.hDuplicateTo sto System.IO.stdout"
                , "let readFileNow f = readFile f >>= \\t -> Data.List.length t `seq` return t"
                , var ++ " <- readFileNow f"
                , "System.Directory.removeFile f"
                ]
        ; _ -> return "putStrLn \"usage: :stdout <var> <cmd>\""
        }
:}


-- * Integration with the hlint code style tool
:{
:def hlint \_ -> return $ unlines
        [ ":unset +t +s"
        , ":set -w"
        , ":stdout hlintvar1 :show modules"
        , ":cmd return (\":!hlint \" ++ (concat $ Data.List.intersperse \" \" "
              ++ "(map (fst . break (==',') . Data.List.drop 2 . snd . "
              ++ "break (== '(')) $ lines hlintvar1)))"
        , ":set +t +s -Wall"
        ]
:}


-- * See also ghc-paths based solutions
:def url        \str -> return $ ":!open -a /Applications/Safari.app " ++ str
:def hoogle     \str -> return $ ":!hoogle --count=15 \"" ++ str ++ "\""
-- :def hoogle_url \str -> return $ ":url http://haskell.org/hoogle/?hoogle=" ++ str
-- :def ??? ":!hoogle --info %" -- what's a good name for that?
:def ghc_pkg    \str -> return $ ":!ghc-pkg " ++ str


-- * With GOA (for reference, rather than actual use)
-- :m - Prelude
-- :m + GOA
-- setLambdabotHome "/Users/wren/.cabal/bin"
-- :def bs        lambdabot "botsnack"
-- :def pl        lambdabot "pl"
-- :def unpl      lambdabot "unpl"
-- :def redo      lambdabot "redo"
-- :def undo      lambdabot "undo"
-- :def index     lambdabot "index"
-- :def docs      lambdabot "docs"
-- :def instances lambdabot "instances"
-- :def hoogle    lambdabot "hoogle"
-- :def source    lambdabot "fptools"
-- :def where     lambdabot "where"
-- :def version   lambdabot "version"
-- :def src       lambdabot "src"


----------------------------------------------------------------
-- * Some language extensions we always want on:
:set -XNoMonomorphismRestriction
:set -XFlexibleContexts
:set -XTypeOperators


-- * Some flags for the debugger
-- For more info see
-- <http://www.haskell.org/ghc/dist/current/docs/users_guide/ghci-debugger.html>
:set -fbreak-on-error
-- :set -fbreak-on-exception


-- * If in a Cabal directory, auto-include Cabal's CPP macros
:set -optP-include -optPdist/build/autogen/cabal_macros.h


-- * Other helpful notes
-- Use -fobject-code            to compile modules before loading.
-- Use -hide-package <pkg>      to do the obvious.
-- Use --extra-lib-dir=/usr/lib to resolve trouble with iconv linking in cabal.
putStrLn ""
putStrLn "\tUse :e to edit the current file, and :r to reload"
putStrLn ""
:set editor vim


-- * Colorful prompt
-- <http://blog.havenisms.com/colorizing-the-ghci-prompt>
-- BUG: this messes up GHCi's readline/editline stuff though. I.e., where the cursor is on the page when linewraps happen, etc. This is still true as of GHC-7.6.3
-- :set prompt "\O33[32;1m%s\O33[34;1m>\O33[0m "
-- Or, if you want the Haskell logo: set your terminal to use one of the <https://github.com/ryanoasis/nerd-fonts> and use e61f (larger) or e777 (smaller).
-- :set prompt "\ESC[94m\STXî˜Ÿ  \ESC[m\STX"

----------------------------------------------------------------
-- These are required for using a local install of bare GHC for work. Of
-- course, this also requires having a local installation that's more
-- up-to-date than the standard one.
-- :set -fplugin=GHC.TypeLits.KnownNat.Solver
-- :set -fplugin=GHC.TypeLits.Extra.Solver
-- :set -fplugin=GHC.TypeLits.Normalise

-- These are from gnezdo at work:
:def test (\t -> return $ "Test.Framework.defaultMain [testCase \"" ++ t ++ "\"" ++ t ++ "]")
:def testp (\t -> return $ "Test.Framework.defaultMain [testProperty \"" ++ t ++ "\"" ++ t ++ "]")

-- * At the end to reduce startup verbiage
:set +s

----------------------------------------------------------------
----------------------------------------------------------- fin.
